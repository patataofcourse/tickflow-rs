### TICKFLOW2 / NEW TICKFLOW* SPECIFICATION ###
=> version 0.1.0-draft3

* Tickflow2 and New Tickflow are working/wip names

~~~~~~~~

Please note that this is an INFORMAL specification, and as such, it does not follow standards such as RFC 2119. In the future, the spec may be cleaned up for higher level of accessibility.

~~~~~~~~

first non-comment non-empty line must be a #new_tickflow directive (see directives section)

there's the following types of values:
- integers (decimal, hex, octal, or binary): 0, 1, 549023, 0x29A, 0o31536, 0b10110
- strings with an optional prefix u for utf-16 strings: "hello ascii", u"hello utf-16"
    - the following characters can be escaped with a backlash: \ "
    - newlines are represented with \n
    - other optional prefixes can be added
- arrays: [0, 1, 2], u16[5, 9, 65535], ["hello", "world"], i8[-127, 0, 127]
    - can contain any number of elements of one type
    - can contain strings or other arrays. example for RHDS:
        const epilogue_strings = [
            // Try Again
            [
                null, // JP
                "hello", // EN
                ...
            ],
            ...
        ]
- identifiers: must start with a letter or _. characters after that can also be numeric
    - identifiers can also refer to elements inside namespaces, like so: $namespace.$element
    - this can be nested as much as needed
    - keywords: reserved identifiers that cannot be used as a sub or constant name
        - true (constant equals to 1)
        - false (constant equals to 0)
        - null (constant equals to 0 that can overwrite a string or array)
        - sub
        - sync
        - const
        - if, if_eq, if_ne, if_gt, if_ge, if_lt, if_le
        - else
        - switch
        - case
        - default
        - raw_op
        - command names are also treated as keywords for the sake of clarity, however, those vary between language implementations
    - identifiers, when taken as arguments, must refer to an existing constant or sub
        - in the case of it being a constant, it will resolve to the value of said constant
        - in the case of it being a sub, it will resolve to a pointer to said sub, which is its own type

you can apply operations to integers:
- addition: a + b
- substraction: a - b
- multiplication: a * b
- integer division: a / b
- shift left: a << b
- shift right: a >> b
- bitwise AND: a & b
- bitwise OR: a | b
- bitwise XOR: a ^ b
- negation: -a
- bitwise NOT: ~a

you can also apply (compile-time) concatenation to strings using the + operator, like addition for integers

statements usually take up a line, but can be terminated by a semicolon. you can add another statement after that semicolon, however, this is only recommended for commands.
lines can be empty
there's the following kinds of statements:
- directives
    - of the form #$name $($args )*
    - $name is specified by the directive definition
    - $args is feeded to the directive. args taken depends on the directive
    - the following directives exist:
        - #new_tickflow
            - required to be read as a Tickflow2 file
            - must be the first non-comment non-empty line in the file
        - #include $filename
            - filename: string, name of the file to include
        - #index $index
            - index: default index to set this mod to target, for a generated mod manifest file. file must not be an includable
        - #name $name
            - name: name of the mod, for a generated mod manifest. file must not be an includable
        - #authors $authors
            - authors: array of names of mod authors, for a generated mod manifest. file must not be an includable
        - #description $description
            - description: description of the mod, for a generated mod manifest. file must not be an includable
        - #version $version
            - version: semver version of the mod, for a generated mod manifest. file must not be an includable
        - #includeme
            - specifies this file can be included and cannot be compiled standalone
        - #module $namespace
            - specifies this file can be included and cannot be compiled standalone
            - all its subs and constants will be included within a namespace called $namespace
        - #requires $version
            - version: semver version of the tickflow spec. needs to match to compile this file
            - if the version is x.y.z, where x != 0, the spec version needed by the compiler is:
                - x needs to match exactly
                - y needs to be greater or equal
                - z needs to be greater or equal if y is equal
            - if the version is 0.y.z, the spec version needed by the compiler is:
                - y needs to match exactly
                - z needs to be greater or equal
        - #tempo $id $samplerate
            - id: id for the tempo file this tempo will target
            - samplerate: optional, sample rate that the tempo file will work with
        - #endtempo
- subs: short for "subroutines", they contain all the actual tickflow bytecode
    - subs are declared with the keyword "sub", the name of the sub, and a pair of curly brackets {}, like so:
        sub $sub_name {
            $sub_contents
        }
    - two subs CANNOT have the same name! this will be a compile-time error
    - before the keyword "sub", the keyword "sync" can be added to indicate that this sub is to be called synchronously, that is, without spawning a new thread
    - the contents of the sub is a list of "command statements" and "syntactic statements", which work the same as any other statement, except they are specific to sub contents:
        - commands are the direct representation of tickflow, abstracted for easier understanding
            - they follow the syntax $name 
            - unlike old Tickflow, arg0s are not to be handled manually in Tickflow2. they are an argument just like any other, or are used to distinguish between two different commands
            - "old Tickflow-like" commands can be used with the "raw_opcode $val $(<$arg0>)? $($args),*" syntax, but val must be a numeric value, not a command definition
            - for commands undefined in the current implementation for a specific language, see the #alias directive
            - the language implementation can abstract these commands as much as it needs to make the language simple and easy to use. optionally, raw variants of these commands may be supplied
        - syntactic statements are the abstraction of some concepts commonly used in tickflow. if they do not exist or cannot be represented in a specific language, the implementation for it can manually disable them. examples are:
            * NOTE: since tickflow usually works with a conditional variable, condition-based statements work by applying a specific comparison to that specific variable and a given constant value
                - if this ever changes (for example, in a "Rhythm Heaven 5" which MUST STILL USE TICKFLOW), the spec may be updated
                - strings and arrays CANNOT be compared to each other unless the language SPECIFICALLY features string/array comparison
            - if / else if / else statements (including if_eq, if_ne, etc. variants)
                if $condition {
                    ...
                } else if_lt $condition {
                    ...
                } else {
                    ...
                }
            - switch / case statements
                switch {
                    case $condition:
                        ...
                        break
                    case $condition:
                        ...
                    case $condition:
                    case $condition:
                        ...
                        break
                    default:
                        ...
                }
                * the final case in the switch/case does not need to include a break statement
            - inconditional loops
                do $number_of_times {
                    ...
                }
                * this will expand the code inside the loop the specific amount of times required if the language does not include an inconditional loop function
                * do n {} MUST NOT alter the conditional variable, or at least must do so in a way that does not affect Tickflow execution
            - conditional loops (including while_eq, while_ne, etc. variants)
                while $condition {
                    ...
                }
                * this will repeat the code inside the loop until the conditional variable succeeds in the comparison
- constant definitions: sets a variable to a certain value, to be used by the file anywhere else
    - form is "const $name = $value"
    - value can be any value Tickflow2 can handle, name has to be a valid variable name
    - you can set constants to sub pointers, other constants or to modifications of other constants, for example:
        const a = 2
        const b = a
        const c = b << 3
        // note that this "inline" format for subs is only used as an example, and is NOT valid Tickflow2
        sub some_sub { ... }
        sub some_other_sub { ... }
        const d = [some_sub, some_other sub]
        const e = [a, b, c]
    - two constants CANNOT have the same name! this will be a compile-time error
- command definitions: creates an alias to any other command, whether an existing definition or a simple raw_op
    - to be written out, have some examples for now
        - command throw_pot = karate.cue 0
        - command async_call a:sub, b:int, c:int = raw_op 0 a, b, c
    - supported types: any, sub, sub_sync, int, u8, u16, u32, i8, i16, i32, $type [] (arrays), str/string

line comments start with a //
multiline comments are started with /* and finished with */, like C comments

each language implementation would include the following, defined in code:
- definitions for commands
    - this is the most important part, because it's what makes Tickflow2 worth it - less need to manually work with hex codes, opening up a more accessible language for newcomers and oldies alike
    - command names may be namespaced
- a standard library, which would be available for any Tickflow2 file to use as a module
    - the module does not need to be called "std"; and most likely will not for accessibility to people not experienced with programming
        - some ideas (for RHM international) are "megamix", "rh3ds", etc.
        - the stardard library MUST NOT be split across several modules, like the Python standard libraries are
    - the contents of the standard library will consist of different subs and constants to enhance the tickflowing experience and give some values a meaning through a name
        - some example of constants that could be defined are: sub names, button codes, scene or game IDs, etc.
        - the standard library may include its items inside namespaces
        - how standard library subs will be written will be described in future versions of the specification, currently Tickflow2 DOES NOT OFFICIALLY SUPPORT STANDARD LIBRARY SUBS, only constants 
- a "runtime"
    - this is a setup system that allows the code to be simplified, similar to Tickflow templates such as EHG's and TheAltDoc's
    - it consists of pre-written Tickflow2 that can be used as a base for less complex charts and projects
    - the runtime must include references or calls to at least one sub that will be defined in the tickflower's code, and may also optionally include references or calls to more user-defined subs or constants
    - the runtime can be overriden at any time by creating a sub named "_start", which will override the runtime's original "_start" sub
        - ways to make runtime overrides more modular may be included in future versions of the specification
    - how the runtime will be written and distributed will be described in future versions of the specification, currently Tickflow2 DOES NOT OFFICIALLY SUPPORT RUNTIMES

### what's left?
- specify a method for runtime and standard library sub creation and distribution
- should we keep the name/author/description/version fields for includables/modules?
- should #includeme and #module be one directive? if so, what could be the name?
    - #module is one possible name, however, that could be confusing, since modules usually involve wrapping in a namespace in programming contexts
- is "syntactic statements" a good name?
- is the language as defined in this spec too jarring of a change? does it still include some inaccessibility issues for people unexperienced with code?
- finish the spec on command statements and re-check the type list
- make the spec cleaner, clearer, and more consistent with more formal language specifications
- convert the spec into some markup format (probably markdown)
- actually implement the spec!
